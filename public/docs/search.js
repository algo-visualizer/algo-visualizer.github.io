window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "visual", "modulename": "visual", "kind": "module", "doc": "<p>Visual API Module</p>\n\n<p>This module provides debugging and visualization capabilities for Python code execution\nin the browser via Pyodide.</p>\n"}, {"fullname": "visual.breakpoint", "modulename": "visual", "qualname": "breakpoint", "kind": "function", "doc": "<p>Breakpoint function that captures variables snapshot at the current execution frame.</p>\n\n<p>This function is called at instrumented breakpoints in the user's code. It creates and returns a Snapshot object\ncontaining the current line number and the graphs of all watchable variables at the top of the global watcher registry stack. Also, it appends the snapshot to the global snapshots container as a side effect.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>condition_expr (str | None):</strong>   An optional boolean expression to evaluate as a condition for capturing the snapshot.\nIf provided, the snapshot will only be captured if the expression evaluates to True.\nThe expression is evaluated in the context of the current execution frame.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Snapshot | None: The captured snapshot at the breakpoint. Returns None if the condition_expr is provided and evaluates to False</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">condition_expr</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">visual</span><span class=\"o\">.</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">snapshot</span><span class=\"o\">.</span><span class=\"n\">Snapshot</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "visual.var", "modulename": "visual", "qualname": "var", "kind": "function", "doc": "<p>Registers variable names to be watched in the snapshot.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>var (str):</strong>  Variable Name to watch.</li>\n<li><strong>*vars (str):</strong>  Additional variable names to watch.</li>\n<li><strong>expr (bool):</strong>  Whether the <code>var</code> and <code>*vars</code> are actually expressions.</li>\n</ul>\n\n<p><strong>Provide variable names or expressions but not both.</strong> <code>expr=False</code> looks up <code>vars</code> arguments by name at locals/globals of the execution frame which has better performance. <code>expr=True</code> treats <code>vars</code> arguments as expressions and directly evaluate them by using <code>eval()</code> during capture.</p>\n\n<p><strong>Use <code>expr=False</code> in most cases.</strong> Use <code>expr=True</code> when you must watch a composite expression or computation that is not stored in a simple variable.</p>\n\n<h6 id=\"examples\">Examples:</h6>\n\n<blockquote>\n  <div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">var</span><span class=\"p\">(</span><span class=\"s1\">&#39;x&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;i&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;global_var&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">var</span><span class=\"p\">(</span><span class=\"s1\">&#39;i+j&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;x+y&#39;</span><span class=\"p\">,</span> <span class=\"n\">expr</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Wrong usage</span>\n<span class=\"n\">var</span><span class=\"p\">()</span>\n<span class=\"n\">var</span><span class=\"p\">(</span><span class=\"s1\">&#39;i+j&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;x+y&#39;</span><span class=\"p\">)</span> <span class=\"c1\"># Didn&#39;t specify that they are expressions</span>\n</code></pre>\n  </div>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>WatcherContext[Var]: The context manager containing the registered watchables.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">var</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"o\">*</span><span class=\"nb\">vars</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">expr</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">visual</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">watcher</span><span class=\"o\">.</span><span class=\"n\">WatcherContext</span><span class=\"p\">[</span><span class=\"n\">visual</span><span class=\"o\">.</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">watchable</span><span class=\"o\">.</span><span class=\"n\">Var</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "visual.array", "modulename": "visual", "qualname": "array", "kind": "function", "doc": "<p>Registers an iterable variable to be watched in the snapshot.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>var (str):</strong>  Variable Name of iterable to watch.</li>\n<li><strong>*vars (str):</strong>  Additional variable names of iterables to watch.</li>\n<li><strong>expr (bool):</strong>  Whether the <code>var</code> and <code>*vars</code> are actually expressions.</li>\n</ul>\n\n<p><strong>Provide variable names or expressions but not both.</strong> <code>expr=False</code> looks up <code>vars</code> arguments by name at locals/globals of the execution frame which has better performance. <code>expr=True</code> treats <code>vars</code> arguments as expressions and directly evaluate them by using <code>eval()</code> during capture.</p>\n\n<p><strong>Use <code>expr=False</code> in most cases.</strong> Use <code>expr=True</code> when you must watch a composite expression or computation that is not stored in a simple variable.</p>\n\n<h6 id=\"examples\">Examples:</h6>\n\n<blockquote>\n  <div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"s1\">&#39;my_list&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;my_deque&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">array</span><span class=\"p\">(</span><span class=\"s1\">&#39;arr[:1]&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;arr.sort()&#39;</span><span class=\"p\">,</span> <span class=\"n\">expr</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">array</span><span class=\"p\">(</span><span class=\"s1\">&#39;my_list&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"p\">(</span><span class=\"s1\">&#39;i&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;j&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">item</span><span class=\"p\">(</span><span class=\"s1\">&#39;target&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"p\">(</span><span class=\"s1\">&#39;i+1&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;i+2&#39;</span><span class=\"p\">,</span> <span class=\"n\">expr</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">array</span><span class=\"p\">(</span><span class=\"s1\">&#39;list1&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;list2&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"p\">(</span><span class=\"s1\">&#39;i&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;j&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">item</span><span class=\"p\">(</span><span class=\"s1\">&#39;target&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"p\">(</span><span class=\"s1\">&#39;i+1&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;i+2&#39;</span><span class=\"p\">,</span> <span class=\"n\">expr</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span> <span class=\"c1\"># Multiple arrays with multiple indexes and items binding</span>\n\n<span class=\"c1\"># Wrong usage</span>\n<span class=\"n\">array</span><span class=\"p\">()</span>\n<span class=\"n\">array</span><span class=\"p\">(</span><span class=\"s1\">&#39;arr[:1]&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;arr.sort()&#39;</span><span class=\"p\">)</span> <span class=\"c1\"># Didn&#39;t specify that they are expressions</span>\n</code></pre>\n  </div>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DSWatcherContext[Array]: The context manager containing the watched variables.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">var</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"o\">*</span><span class=\"nb\">vars</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">expr</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">visual</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">watcher</span><span class=\"o\">.</span><span class=\"n\">DSWatcherContext</span><span class=\"p\">[</span><span class=\"n\">visual</span><span class=\"o\">.</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">watchable</span><span class=\"o\">.</span><span class=\"n\">Array</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "visual.array2d", "modulename": "visual", "qualname": "array2d", "kind": "function", "doc": "<p>Registers an 2-dimensional iterable variable to be watched in the snapshot.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>var (str):</strong>  Variable Name of 2-dimensional iterable to watch.</li>\n<li><strong>*vars (str):</strong>  Additional variable names of 2-dimensional iterables to watch.</li>\n<li><strong>expr (bool):</strong>  Whether the <code>var</code> and <code>*vars</code> are actually expressions.</li>\n</ul>\n\n<p><strong>Provide variable names or expressions but not both.</strong> <code>expr=False</code> looks up <code>vars</code> arguments by name at locals/globals of the execution frame which has better performance. <code>expr=True</code> treats <code>vars</code> arguments as expressions and directly evaluate them by using <code>eval()</code> during capture.</p>\n\n<p><strong>Use <code>expr=False</code> in most cases.</strong> Use <code>expr=True</code> when you must watch a composite expression or computation that is not stored in a simple variable.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DSWatcherContext[Array2D]: The context manager containing the watched variables.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">var</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"o\">*</span><span class=\"nb\">vars</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">expr</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">visual</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">watcher</span><span class=\"o\">.</span><span class=\"n\">DSWatcherContext</span><span class=\"p\">[</span><span class=\"n\">visual</span><span class=\"o\">.</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">watchable</span><span class=\"o\">.</span><span class=\"n\">Array2D</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "visual.nodes", "modulename": "visual", "qualname": "nodes", "kind": "function", "doc": "<p>Registers a nodes variable to be watched in the snapshot.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>var (str):</strong>  Variable name of the nodes structure to watch.</li>\n<li><p><strong>head_id (Callable):</strong>   Function to get the head id from the nodes. Id must be an integer or string. You can use <code>repr</code> and <code>eval</code> to convert complex ids to string and back.\nExample:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">head_id</span><span class=\"p\">(</span><span class=\"n\">nodes</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">nodes</span><span class=\"o\">.</span><span class=\"n\">head_id</span>\n</code></pre>\n</div></li>\n<li><p><strong>next_ids (Callable):</strong>   Function to get the next ids and weights from a given id. Weight is defaulted to 1 if not provided. Id must be an integer or string (None means no next ids). You can use <code>repr</code> and <code>eval</code> to convert complex ids to string and back.\nExample:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">next_ids</span><span class=\"p\">(</span><span class=\"n\">nodes</span><span class=\"p\">,</span> <span class=\"nb\">id</span><span class=\"p\">):</span>\n    <span class=\"n\">next_nodes</span> <span class=\"o\">=</span> <span class=\"n\">nodes</span><span class=\"p\">[</span><span class=\"nb\">id</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">nexts</span>\n    <span class=\"k\">return</span> <span class=\"p\">[(</span><span class=\"n\">next_node</span><span class=\"o\">.</span><span class=\"n\">id</span><span class=\"p\">,</span> <span class=\"n\">next_node</span><span class=\"o\">.</span><span class=\"n\">weight</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">next_node</span> <span class=\"ow\">in</span> <span class=\"n\">next_nodes</span><span class=\"p\">]</span>\n</code></pre>\n</div></li>\n<li><p><strong>value (Callable):</strong>   Function to get the node value (the actual object) from a given id.\nExample:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">value</span><span class=\"p\">(</span><span class=\"n\">nodes</span><span class=\"p\">,</span> <span class=\"nb\">id</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">nodes</span><span class=\"p\">[</span><span class=\"nb\">id</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">value</span>\n</code></pre>\n</div></li>\n<li><p><strong>expr (bool):</strong>   Whether the <code>var</code> is an expression.</p></li>\n</ul>\n\n<p><strong>Provide variable name or expression.</strong> <code>expr=False</code> looks up <code>var</code> by name at locals/globals of the execution frame which has better performance. <code>expr=True</code> treats <code>var</code> as an expression and directly evaluate it by using <code>eval()</code> during capture.</p>\n\n<p><strong>Use <code>expr=False</code> in most cases.</strong> Use <code>expr=True</code> when you must watch a composite expression or computation that is not stored in a simple variable.</p>\n\n<h6 id=\"examples\">Examples:</h6>\n\n<blockquote>\n  <div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">nodes</span><span class=\"p\">(</span><span class=\"s1\">&#39;linked_list&#39;</span><span class=\"p\">)</span> \n<span class=\"n\">nodes</span><span class=\"p\">(</span><span class=\"s1\">&#39;graph_nodes&#39;</span><span class=\"p\">,</span> <span class=\"n\">get_head_id</span><span class=\"p\">,</span> <span class=\"n\">get_next_ids</span><span class=\"p\">,</span> <span class=\"n\">get_value</span><span class=\"p\">)</span> <span class=\"c1\"># Custom node definitions</span>\n<span class=\"n\">nodes</span><span class=\"p\">(</span><span class=\"s1\">&#39;linked_lists[0]&#39;</span><span class=\"p\">,</span> <span class=\"n\">expr</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">nodes</span><span class=\"p\">(</span><span class=\"s1\">&#39;linked_list&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"p\">(</span><span class=\"s1\">&#39;i&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;j&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">item</span><span class=\"p\">(</span><span class=\"s1\">&#39;node&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"p\">(</span><span class=\"s1\">&#39;i+1&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;j+1&#39;</span><span class=\"p\">,</span> <span class=\"n\">expr</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Wrong usage</span>\n<span class=\"n\">nodes</span><span class=\"p\">(</span><span class=\"s1\">&#39;linked_list[0]&#39;</span><span class=\"p\">)</span> <span class=\"c1\"># Didn&#39;t specify that it&#39;s an expression</span>\n</code></pre>\n  </div>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DSWatcherContext: The context manager containing the registered Nodes watchable.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">var</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">head_id</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">_NodesType</span><span class=\"p\">],</span> <span class=\"n\">_IdType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">_HEAD_ID_FUNC_DEFAULT</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">next_ids</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">_NodesType</span><span class=\"p\">,</span> <span class=\"n\">_IdType</span><span class=\"p\">],</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">_IdType</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">_IdType</span><span class=\"p\">,</span> <span class=\"n\">_WeightType</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">_IdType</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">_IdType</span><span class=\"p\">,</span> <span class=\"n\">_WeightType</span><span class=\"p\">]]]]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">_NEXT_IDS_FUNC_DEFAULT</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">_NodesType</span><span class=\"p\">,</span> <span class=\"n\">_IdType</span><span class=\"p\">],</span> <span class=\"n\">_NodeType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">_VALUE_FUNC_DEFAULT</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">expr</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">visual</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">watcher</span><span class=\"o\">.</span><span class=\"n\">DSWatcherContext</span><span class=\"p\">[</span><span class=\"n\">visual</span><span class=\"o\">.</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">watchable</span><span class=\"o\">.</span><span class=\"n\">Nodes</span><span class=\"p\">[</span><span class=\"n\">_NodesType</span><span class=\"p\">,</span> <span class=\"n\">_NodeType</span><span class=\"p\">,</span> <span class=\"n\">_IdType</span><span class=\"p\">,</span> <span class=\"n\">_WeightType</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "visual.core", "modulename": "visual.core", "kind": "module", "doc": "<p>Visual Core Module</p>\n\n<p>Core functionality for code instrumentation and variable snapshotting.\nThis module is designed to work with Pyodide in the browser environment.\n<strong>It should only be used by algo-visualizer developers instead of end users.</strong></p>\n"}, {"fullname": "visual.core.watcher", "modulename": "visual.core.watcher", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "visual.core.watcher.WatcherContext", "modulename": "visual.core.watcher", "qualname": "WatcherContext", "kind": "class", "doc": "<p>Abstract base class for generic types.</p>\n\n<p>On Python 3.12 and newer, generic classes implicitly inherit from\nGeneric when they declare a parameter list after the class's name::</p>\n\n<pre><code>class Mapping[KT, VT]:\n    def __getitem__(self, key: KT) -&gt; VT:\n        ...\n    # Etc.\n</code></pre>\n\n<p>On older versions of Python, however, generic classes have to\nexplicitly inherit from Generic.</p>\n\n<p>After a class has been declared to be generic, it can then be used as\nfollows::</p>\n\n<pre><code>def lookup_name[KT, VT](mapping: Mapping[KT, VT], key: KT, default: VT) -&gt; VT:\n    try:\n        return mapping[key]\n    except KeyError:\n        return default\n</code></pre>\n", "bases": "typing.Generic[T]"}, {"fullname": "visual.core.watcher.WatcherContext.__init__", "modulename": "visual.core.watcher", "qualname": "WatcherContext.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">watchables</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "visual.core.watcher.WatcherContext.watchables", "modulename": "visual.core.watcher", "qualname": "WatcherContext.watchables", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "visual.core.watcher.DSWatcherContext", "modulename": "visual.core.watcher", "qualname": "DSWatcherContext", "kind": "class", "doc": "<p>Abstract base class for generic types.</p>\n\n<p>On Python 3.12 and newer, generic classes implicitly inherit from\nGeneric when they declare a parameter list after the class's name::</p>\n\n<pre><code>class Mapping[KT, VT]:\n    def __getitem__(self, key: KT) -&gt; VT:\n        ...\n    # Etc.\n</code></pre>\n\n<p>On older versions of Python, however, generic classes have to\nexplicitly inherit from Generic.</p>\n\n<p>After a class has been declared to be generic, it can then be used as\nfollows::</p>\n\n<pre><code>def lookup_name[KT, VT](mapping: Mapping[KT, VT], key: KT, default: VT) -&gt; VT:\n    try:\n        return mapping[key]\n    except KeyError:\n        return default\n</code></pre>\n", "bases": "visual.core.watcher.WatcherContext[T], typing.Generic[T]"}, {"fullname": "visual.core.watcher.DSWatcherContext.__init__", "modulename": "visual.core.watcher", "qualname": "DSWatcherContext.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">watchables</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "visual.core.watcher.DSWatcherContext.index", "modulename": "visual.core.watcher", "qualname": "DSWatcherContext.index", "kind": "function", "doc": "<p>Register variables to be used as index pointers for all DS watchables.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>var (str):</strong>  The variable name to be used as index pointer.</li>\n<li><strong>*vars (str):</strong>  Additional variable names to be used as index pointers.</li>\n<li><strong>expr (bool):</strong>  Whether the <code>var</code> and <code>*vars</code> are actually expressions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DSWatcherContext: Returns self to enable method chaining.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">var</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"nb\">vars</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">expr</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "visual.core.watcher.DSWatcherContext.item", "modulename": "visual.core.watcher", "qualname": "DSWatcherContext.item", "kind": "function", "doc": "<p>Register variables to be used as item pointers for all DS watchables.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>var (str):</strong>  The variable name to be used as item pointer.</li>\n<li><strong>*vars (str):</strong>  Additional variable names to be used as item pointers.</li>\n<li><strong>expr (bool):</strong>  Whether the <code>var</code> and <code>*vars</code> are actually expressions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DSWatcherContext: Returns self to enable method chaining.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">var</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"nb\">vars</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">expr</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "visual.core.watcher.watch", "modulename": "visual.core.watcher", "qualname": "watch", "kind": "function", "doc": "<p><strong>DO NOT use this function directly. Use <code>var</code>, <code>array</code>, <code>nodes</code> etc. instead.</strong></p>\n\n<p>Registers the watchable to the top of the global watcher registry stack. </p>\n\n<p>Since the <code>watch</code> system design principle is:<br />\n<em>Information increment is always better than decrement.</em><br />\nthe watchable will be appended to the global watcher registry stack instead of replacing the old one. <strong>If the corresponding variable name didn't get <code>unwatch</code>ed, the last registered watchable with that variable name will be kept.</strong></p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>watchable (Watchable):</strong>  The watchable to register.</li>\n<li><strong>*watchables (Watchable):</strong>  Additional watchables to register.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">watchable</span><span class=\"p\">:</span> <span class=\"n\">visual</span><span class=\"o\">.</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">watchable</span><span class=\"o\">.</span><span class=\"n\">Watchable</span>,</span><span class=\"param\">\t<span class=\"o\">*</span><span class=\"n\">watchables</span><span class=\"p\">:</span> <span class=\"n\">visual</span><span class=\"o\">.</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">watchable</span><span class=\"o\">.</span><span class=\"n\">Watchable</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "visual.core.watcher.unwatch", "modulename": "visual.core.watcher", "qualname": "unwatch", "kind": "function", "doc": "<p><strong>NOT recommended to use this function directly, especially in pure-top-level code. Use <code>with</code> statement instead.</strong></p>\n\n<p>Unregisters the last registered watchable with that variable name from the global watcher registry stack. </p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>var (str):</strong>  The name of the variable to unregister.</li>\n<li><strong>*vars (str):</strong>  Additional variables to unregister.</li>\n</ul>\n\n<p>In some cases like declaring watchable in a function, you can use it via <code>with</code> statement:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">some_func</span><span class=\"p\">():</span>\n    <span class=\"k\">with</span> <span class=\"n\">var</span><span class=\"p\">(</span><span class=\"s1\">&#39;x&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;y&#39;</span><span class=\"p\">):</span>\n        <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span>\n        <span class=\"k\">with</span> <span class=\"n\">array</span><span class=\"p\">(</span><span class=\"s1\">&#39;a&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;b&#39;</span><span class=\"p\">):</span>\n            <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">]</span>\n            <span class=\"o\">...</span>\n        <span class=\"c1\"># &#39;a&#39;, &#39;b&#39; unwatched implicitly</span>\n        <span class=\"o\">...</span>\n    <span class=\"c1\"># &#39;x&#39;, &#39;y&#39; unwatched implicitly</span>\n    <span class=\"k\">return</span>\n</code></pre>\n</div>\n\n<p><strong>It will implcitly call <code>unwatch</code> when the <code>with</code> block is exited.</strong></p>\n\n<p><code>unwatch</code> will only unregister the watchable that is top of the stack. For example:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">var</span><span class=\"p\">(</span><span class=\"s1\">&#39;x&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;y&#39;</span><span class=\"p\">)</span> <span class=\"c1\"># Pure top-level watcher. No `unwatch` needed.</span>\n\n<span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">some_func</span><span class=\"p\">():</span>\n    <span class=\"k\">with</span> <span class=\"n\">var</span><span class=\"p\">(</span><span class=\"s1\">&#39;x&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;y&#39;</span><span class=\"p\">):</span>\n        <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span>\n        <span class=\"o\">...</span>\n    <span class=\"c1\"># Inner &#39;x&#39;, &#39;y&#39; unwatched implicitly, outer &#39;x&#39;, &#39;y&#39; still watched.</span>\n    <span class=\"k\">return</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">var</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"nb\">vars</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "visual.core.watcher.get_registry", "modulename": "visual.core.watcher", "qualname": "get_registry", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">deque</span><span class=\"p\">[</span><span class=\"n\">visual</span><span class=\"o\">.</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">watchable</span><span class=\"o\">.</span><span class=\"n\">Watchable</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "visual.core.watcher.clear", "modulename": "visual.core.watcher", "qualname": "clear", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "visual.types", "modulename": "visual.types", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "visual.types.graph", "modulename": "visual.types.graph", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "visual.types.graph.GraphUnion", "modulename": "visual.types.graph", "qualname": "GraphUnion", "kind": "variable", "doc": "<p></p>\n", "default_value": "visual.types.graph.VarGraph | visual.types.graph.ArrayGraph | visual.types.graph.Array2DGraph | visual.types.graph.NodesGraph"}, {"fullname": "visual.types.graph.GraphGroup", "modulename": "visual.types.graph", "qualname": "GraphGroup", "kind": "variable", "doc": "<p></p>\n", "default_value": "dict[str, typing.Annotated[GraphUnion, FieldInfo(annotation=NoneType, required=True, discriminator=&#x27;type&#x27;)]]"}, {"fullname": "visual.types.graph.Graph", "modulename": "visual.types.graph", "qualname": "Graph", "kind": "class", "doc": "<p>!!! abstract \"Usage Documentation\"\n    <a href=\"../concepts/models.md\">Models</a></p>\n\n<p>A base class for creating Pydantic models.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>__class_vars__:</strong>  The names of the class variables defined on the model.</li>\n<li><strong>__private_attributes__:</strong>  Metadata about the private attributes of the model.</li>\n<li><strong>__signature__:</strong>  The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</li>\n<li><strong>__pydantic_complete__:</strong>  Whether model building is completed, or if there are still undefined fields.</li>\n<li><strong>__pydantic_core_schema__:</strong>  The core schema of the model.</li>\n<li><strong>__pydantic_custom_init__:</strong>  Whether the model has a custom <code>__init__</code> function.</li>\n<li><strong>__pydantic_decorators__:</strong>  Metadata containing the decorators defined on the model.\nThis replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</li>\n<li><strong>__pydantic_generic_metadata__:</strong>  Metadata for generic models; contains data used for a similar purpose to\n__args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.</li>\n<li><strong>__pydantic_parent_namespace__:</strong>  Parent namespace of the model, used for automatic rebuilding of models.</li>\n<li><strong>__pydantic_post_init__:</strong>  The name of the post-init method for the model, if defined.</li>\n<li><strong>__pydantic_root_model__:</strong>  Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</li>\n<li><strong>__pydantic_serializer__:</strong>  The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</li>\n<li><strong>__pydantic_validator__:</strong>  The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</li>\n<li><strong>__pydantic_fields__:</strong>  A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</li>\n<li><strong>__pydantic_computed_fields__:</strong>  A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</li>\n<li><strong>__pydantic_extra__:</strong>  A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]\nis set to <code>'allow'</code>.</li>\n<li><strong>__pydantic_fields_set__:</strong>  The names of fields explicitly set during instantiation.</li>\n<li><strong>__pydantic_private__:</strong>  Values of private attributes set on the model instance.</li>\n</ul>\n", "bases": "pydantic.main.BaseModel"}, {"fullname": "visual.types.graph.Graph.frameid", "modulename": "visual.types.graph", "qualname": "Graph.frameid", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": "PydanticUndefined"}, {"fullname": "visual.types.graph.Graph.parent_frameid", "modulename": "visual.types.graph", "qualname": "Graph.parent_frameid", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str | None", "default_value": "PydanticUndefined"}, {"fullname": "visual.types.graph.Graph.notcaptured", "modulename": "visual.types.graph", "qualname": "Graph.notcaptured", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": "PydanticUndefined"}, {"fullname": "visual.types.graph.VarGraph", "modulename": "visual.types.graph", "qualname": "VarGraph", "kind": "class", "doc": "<p>!!! abstract \"Usage Documentation\"\n    <a href=\"../concepts/models.md\">Models</a></p>\n\n<p>A base class for creating Pydantic models.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>__class_vars__:</strong>  The names of the class variables defined on the model.</li>\n<li><strong>__private_attributes__:</strong>  Metadata about the private attributes of the model.</li>\n<li><strong>__signature__:</strong>  The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</li>\n<li><strong>__pydantic_complete__:</strong>  Whether model building is completed, or if there are still undefined fields.</li>\n<li><strong>__pydantic_core_schema__:</strong>  The core schema of the model.</li>\n<li><strong>__pydantic_custom_init__:</strong>  Whether the model has a custom <code>__init__</code> function.</li>\n<li><strong>__pydantic_decorators__:</strong>  Metadata containing the decorators defined on the model.\nThis replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</li>\n<li><strong>__pydantic_generic_metadata__:</strong>  Metadata for generic models; contains data used for a similar purpose to\n__args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.</li>\n<li><strong>__pydantic_parent_namespace__:</strong>  Parent namespace of the model, used for automatic rebuilding of models.</li>\n<li><strong>__pydantic_post_init__:</strong>  The name of the post-init method for the model, if defined.</li>\n<li><strong>__pydantic_root_model__:</strong>  Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</li>\n<li><strong>__pydantic_serializer__:</strong>  The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</li>\n<li><strong>__pydantic_validator__:</strong>  The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</li>\n<li><strong>__pydantic_fields__:</strong>  A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</li>\n<li><strong>__pydantic_computed_fields__:</strong>  A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</li>\n<li><strong>__pydantic_extra__:</strong>  A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]\nis set to <code>'allow'</code>.</li>\n<li><strong>__pydantic_fields_set__:</strong>  The names of fields explicitly set during instantiation.</li>\n<li><strong>__pydantic_private__:</strong>  Values of private attributes set on the model instance.</li>\n</ul>\n", "bases": "Graph"}, {"fullname": "visual.types.graph.VarGraph.type", "modulename": "visual.types.graph", "qualname": "VarGraph.type", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Literal[&#x27;var&#x27;]", "default_value": "&#x27;var&#x27;"}, {"fullname": "visual.types.graph.VarGraph.content", "modulename": "visual.types.graph", "qualname": "VarGraph.content", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": "PydanticUndefined"}, {"fullname": "visual.types.graph.Pointer", "modulename": "visual.types.graph", "qualname": "Pointer", "kind": "class", "doc": "<p>!!! abstract \"Usage Documentation\"\n    <a href=\"../concepts/models.md\">Models</a></p>\n\n<p>A base class for creating Pydantic models.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>__class_vars__:</strong>  The names of the class variables defined on the model.</li>\n<li><strong>__private_attributes__:</strong>  Metadata about the private attributes of the model.</li>\n<li><strong>__signature__:</strong>  The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</li>\n<li><strong>__pydantic_complete__:</strong>  Whether model building is completed, or if there are still undefined fields.</li>\n<li><strong>__pydantic_core_schema__:</strong>  The core schema of the model.</li>\n<li><strong>__pydantic_custom_init__:</strong>  Whether the model has a custom <code>__init__</code> function.</li>\n<li><strong>__pydantic_decorators__:</strong>  Metadata containing the decorators defined on the model.\nThis replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</li>\n<li><strong>__pydantic_generic_metadata__:</strong>  Metadata for generic models; contains data used for a similar purpose to\n__args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.</li>\n<li><strong>__pydantic_parent_namespace__:</strong>  Parent namespace of the model, used for automatic rebuilding of models.</li>\n<li><strong>__pydantic_post_init__:</strong>  The name of the post-init method for the model, if defined.</li>\n<li><strong>__pydantic_root_model__:</strong>  Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</li>\n<li><strong>__pydantic_serializer__:</strong>  The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</li>\n<li><strong>__pydantic_validator__:</strong>  The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</li>\n<li><strong>__pydantic_fields__:</strong>  A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</li>\n<li><strong>__pydantic_computed_fields__:</strong>  A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</li>\n<li><strong>__pydantic_extra__:</strong>  A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]\nis set to <code>'allow'</code>.</li>\n<li><strong>__pydantic_fields_set__:</strong>  The names of fields explicitly set during instantiation.</li>\n<li><strong>__pydantic_private__:</strong>  Values of private attributes set on the model instance.</li>\n</ul>\n", "bases": "pydantic.main.BaseModel"}, {"fullname": "visual.types.graph.Pointer.name", "modulename": "visual.types.graph", "qualname": "Pointer.name", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": "PydanticUndefined"}, {"fullname": "visual.types.graph.Pointer.index", "modulename": "visual.types.graph", "qualname": "Pointer.index", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int | str", "default_value": "PydanticUndefined"}, {"fullname": "visual.types.graph.Pointer.notcaptured", "modulename": "visual.types.graph", "qualname": "Pointer.notcaptured", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": "PydanticUndefined"}, {"fullname": "visual.types.graph.Pointer2D", "modulename": "visual.types.graph", "qualname": "Pointer2D", "kind": "class", "doc": "<p>!!! abstract \"Usage Documentation\"\n    <a href=\"../concepts/models.md\">Models</a></p>\n\n<p>A base class for creating Pydantic models.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>__class_vars__:</strong>  The names of the class variables defined on the model.</li>\n<li><strong>__private_attributes__:</strong>  Metadata about the private attributes of the model.</li>\n<li><strong>__signature__:</strong>  The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</li>\n<li><strong>__pydantic_complete__:</strong>  Whether model building is completed, or if there are still undefined fields.</li>\n<li><strong>__pydantic_core_schema__:</strong>  The core schema of the model.</li>\n<li><strong>__pydantic_custom_init__:</strong>  Whether the model has a custom <code>__init__</code> function.</li>\n<li><strong>__pydantic_decorators__:</strong>  Metadata containing the decorators defined on the model.\nThis replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</li>\n<li><strong>__pydantic_generic_metadata__:</strong>  Metadata for generic models; contains data used for a similar purpose to\n__args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.</li>\n<li><strong>__pydantic_parent_namespace__:</strong>  Parent namespace of the model, used for automatic rebuilding of models.</li>\n<li><strong>__pydantic_post_init__:</strong>  The name of the post-init method for the model, if defined.</li>\n<li><strong>__pydantic_root_model__:</strong>  Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</li>\n<li><strong>__pydantic_serializer__:</strong>  The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</li>\n<li><strong>__pydantic_validator__:</strong>  The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</li>\n<li><strong>__pydantic_fields__:</strong>  A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</li>\n<li><strong>__pydantic_computed_fields__:</strong>  A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</li>\n<li><strong>__pydantic_extra__:</strong>  A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]\nis set to <code>'allow'</code>.</li>\n<li><strong>__pydantic_fields_set__:</strong>  The names of fields explicitly set during instantiation.</li>\n<li><strong>__pydantic_private__:</strong>  Values of private attributes set on the model instance.</li>\n</ul>\n", "bases": "pydantic.main.BaseModel"}, {"fullname": "visual.types.graph.Pointer2D.name", "modulename": "visual.types.graph", "qualname": "Pointer2D.name", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": "PydanticUndefined"}, {"fullname": "visual.types.graph.Pointer2D.index", "modulename": "visual.types.graph", "qualname": "Pointer2D.index", "kind": "variable", "doc": "<p></p>\n", "annotation": ": tuple[int, int] | str", "default_value": "PydanticUndefined"}, {"fullname": "visual.types.graph.Pointer2D.notcaptured", "modulename": "visual.types.graph", "qualname": "Pointer2D.notcaptured", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": "PydanticUndefined"}, {"fullname": "visual.types.graph.ArrayGraph", "modulename": "visual.types.graph", "qualname": "ArrayGraph", "kind": "class", "doc": "<p>!!! abstract \"Usage Documentation\"\n    <a href=\"../concepts/models.md\">Models</a></p>\n\n<p>A base class for creating Pydantic models.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>__class_vars__:</strong>  The names of the class variables defined on the model.</li>\n<li><strong>__private_attributes__:</strong>  Metadata about the private attributes of the model.</li>\n<li><strong>__signature__:</strong>  The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</li>\n<li><strong>__pydantic_complete__:</strong>  Whether model building is completed, or if there are still undefined fields.</li>\n<li><strong>__pydantic_core_schema__:</strong>  The core schema of the model.</li>\n<li><strong>__pydantic_custom_init__:</strong>  Whether the model has a custom <code>__init__</code> function.</li>\n<li><strong>__pydantic_decorators__:</strong>  Metadata containing the decorators defined on the model.\nThis replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</li>\n<li><strong>__pydantic_generic_metadata__:</strong>  Metadata for generic models; contains data used for a similar purpose to\n__args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.</li>\n<li><strong>__pydantic_parent_namespace__:</strong>  Parent namespace of the model, used for automatic rebuilding of models.</li>\n<li><strong>__pydantic_post_init__:</strong>  The name of the post-init method for the model, if defined.</li>\n<li><strong>__pydantic_root_model__:</strong>  Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</li>\n<li><strong>__pydantic_serializer__:</strong>  The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</li>\n<li><strong>__pydantic_validator__:</strong>  The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</li>\n<li><strong>__pydantic_fields__:</strong>  A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</li>\n<li><strong>__pydantic_computed_fields__:</strong>  A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</li>\n<li><strong>__pydantic_extra__:</strong>  A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]\nis set to <code>'allow'</code>.</li>\n<li><strong>__pydantic_fields_set__:</strong>  The names of fields explicitly set during instantiation.</li>\n<li><strong>__pydantic_private__:</strong>  Values of private attributes set on the model instance.</li>\n</ul>\n", "bases": "Graph"}, {"fullname": "visual.types.graph.ArrayGraph.type", "modulename": "visual.types.graph", "qualname": "ArrayGraph.type", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Literal[&#x27;array&#x27;]", "default_value": "&#x27;array&#x27;"}, {"fullname": "visual.types.graph.ArrayGraph.content", "modulename": "visual.types.graph", "qualname": "ArrayGraph.content", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str | visual.types.graph.ArrayGraphContent", "default_value": "PydanticUndefined"}, {"fullname": "visual.types.graph.ArrayGraphContent", "modulename": "visual.types.graph", "qualname": "ArrayGraphContent", "kind": "class", "doc": "<p>!!! abstract \"Usage Documentation\"\n    <a href=\"../concepts/models.md\">Models</a></p>\n\n<p>A base class for creating Pydantic models.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>__class_vars__:</strong>  The names of the class variables defined on the model.</li>\n<li><strong>__private_attributes__:</strong>  Metadata about the private attributes of the model.</li>\n<li><strong>__signature__:</strong>  The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</li>\n<li><strong>__pydantic_complete__:</strong>  Whether model building is completed, or if there are still undefined fields.</li>\n<li><strong>__pydantic_core_schema__:</strong>  The core schema of the model.</li>\n<li><strong>__pydantic_custom_init__:</strong>  Whether the model has a custom <code>__init__</code> function.</li>\n<li><strong>__pydantic_decorators__:</strong>  Metadata containing the decorators defined on the model.\nThis replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</li>\n<li><strong>__pydantic_generic_metadata__:</strong>  Metadata for generic models; contains data used for a similar purpose to\n__args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.</li>\n<li><strong>__pydantic_parent_namespace__:</strong>  Parent namespace of the model, used for automatic rebuilding of models.</li>\n<li><strong>__pydantic_post_init__:</strong>  The name of the post-init method for the model, if defined.</li>\n<li><strong>__pydantic_root_model__:</strong>  Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</li>\n<li><strong>__pydantic_serializer__:</strong>  The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</li>\n<li><strong>__pydantic_validator__:</strong>  The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</li>\n<li><strong>__pydantic_fields__:</strong>  A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</li>\n<li><strong>__pydantic_computed_fields__:</strong>  A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</li>\n<li><strong>__pydantic_extra__:</strong>  A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]\nis set to <code>'allow'</code>.</li>\n<li><strong>__pydantic_fields_set__:</strong>  The names of fields explicitly set during instantiation.</li>\n<li><strong>__pydantic_private__:</strong>  Values of private attributes set on the model instance.</li>\n</ul>\n", "bases": "pydantic.main.BaseModel"}, {"fullname": "visual.types.graph.ArrayGraphContent.value", "modulename": "visual.types.graph", "qualname": "ArrayGraphContent.value", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list[str]", "default_value": "PydanticUndefined"}, {"fullname": "visual.types.graph.ArrayGraphContent.pointers", "modulename": "visual.types.graph", "qualname": "ArrayGraphContent.pointers", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list[visual.types.graph.Pointer]", "default_value": "PydanticUndefined"}, {"fullname": "visual.types.graph.Array2DGraph", "modulename": "visual.types.graph", "qualname": "Array2DGraph", "kind": "class", "doc": "<p>!!! abstract \"Usage Documentation\"\n    <a href=\"../concepts/models.md\">Models</a></p>\n\n<p>A base class for creating Pydantic models.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>__class_vars__:</strong>  The names of the class variables defined on the model.</li>\n<li><strong>__private_attributes__:</strong>  Metadata about the private attributes of the model.</li>\n<li><strong>__signature__:</strong>  The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</li>\n<li><strong>__pydantic_complete__:</strong>  Whether model building is completed, or if there are still undefined fields.</li>\n<li><strong>__pydantic_core_schema__:</strong>  The core schema of the model.</li>\n<li><strong>__pydantic_custom_init__:</strong>  Whether the model has a custom <code>__init__</code> function.</li>\n<li><strong>__pydantic_decorators__:</strong>  Metadata containing the decorators defined on the model.\nThis replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</li>\n<li><strong>__pydantic_generic_metadata__:</strong>  Metadata for generic models; contains data used for a similar purpose to\n__args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.</li>\n<li><strong>__pydantic_parent_namespace__:</strong>  Parent namespace of the model, used for automatic rebuilding of models.</li>\n<li><strong>__pydantic_post_init__:</strong>  The name of the post-init method for the model, if defined.</li>\n<li><strong>__pydantic_root_model__:</strong>  Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</li>\n<li><strong>__pydantic_serializer__:</strong>  The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</li>\n<li><strong>__pydantic_validator__:</strong>  The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</li>\n<li><strong>__pydantic_fields__:</strong>  A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</li>\n<li><strong>__pydantic_computed_fields__:</strong>  A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</li>\n<li><strong>__pydantic_extra__:</strong>  A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]\nis set to <code>'allow'</code>.</li>\n<li><strong>__pydantic_fields_set__:</strong>  The names of fields explicitly set during instantiation.</li>\n<li><strong>__pydantic_private__:</strong>  Values of private attributes set on the model instance.</li>\n</ul>\n", "bases": "Graph"}, {"fullname": "visual.types.graph.Array2DGraph.type", "modulename": "visual.types.graph", "qualname": "Array2DGraph.type", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Literal[&#x27;array2d&#x27;]", "default_value": "&#x27;array2d&#x27;"}, {"fullname": "visual.types.graph.Array2DGraph.content", "modulename": "visual.types.graph", "qualname": "Array2DGraph.content", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str | visual.types.graph.Array2DGraphContent", "default_value": "PydanticUndefined"}, {"fullname": "visual.types.graph.Array2DGraphContent", "modulename": "visual.types.graph", "qualname": "Array2DGraphContent", "kind": "class", "doc": "<p>!!! abstract \"Usage Documentation\"\n    <a href=\"../concepts/models.md\">Models</a></p>\n\n<p>A base class for creating Pydantic models.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>__class_vars__:</strong>  The names of the class variables defined on the model.</li>\n<li><strong>__private_attributes__:</strong>  Metadata about the private attributes of the model.</li>\n<li><strong>__signature__:</strong>  The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</li>\n<li><strong>__pydantic_complete__:</strong>  Whether model building is completed, or if there are still undefined fields.</li>\n<li><strong>__pydantic_core_schema__:</strong>  The core schema of the model.</li>\n<li><strong>__pydantic_custom_init__:</strong>  Whether the model has a custom <code>__init__</code> function.</li>\n<li><strong>__pydantic_decorators__:</strong>  Metadata containing the decorators defined on the model.\nThis replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</li>\n<li><strong>__pydantic_generic_metadata__:</strong>  Metadata for generic models; contains data used for a similar purpose to\n__args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.</li>\n<li><strong>__pydantic_parent_namespace__:</strong>  Parent namespace of the model, used for automatic rebuilding of models.</li>\n<li><strong>__pydantic_post_init__:</strong>  The name of the post-init method for the model, if defined.</li>\n<li><strong>__pydantic_root_model__:</strong>  Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</li>\n<li><strong>__pydantic_serializer__:</strong>  The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</li>\n<li><strong>__pydantic_validator__:</strong>  The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</li>\n<li><strong>__pydantic_fields__:</strong>  A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</li>\n<li><strong>__pydantic_computed_fields__:</strong>  A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</li>\n<li><strong>__pydantic_extra__:</strong>  A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]\nis set to <code>'allow'</code>.</li>\n<li><strong>__pydantic_fields_set__:</strong>  The names of fields explicitly set during instantiation.</li>\n<li><strong>__pydantic_private__:</strong>  Values of private attributes set on the model instance.</li>\n</ul>\n", "bases": "pydantic.main.BaseModel"}, {"fullname": "visual.types.graph.Array2DGraphContent.value", "modulename": "visual.types.graph", "qualname": "Array2DGraphContent.value", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list[list[str]]", "default_value": "PydanticUndefined"}, {"fullname": "visual.types.graph.Array2DGraphContent.pointers", "modulename": "visual.types.graph", "qualname": "Array2DGraphContent.pointers", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list[visual.types.graph.Pointer2D]", "default_value": "PydanticUndefined"}, {"fullname": "visual.types.graph.NodeId", "modulename": "visual.types.graph", "qualname": "NodeId", "kind": "variable", "doc": "<p></p>\n", "default_value": "int | str | None"}, {"fullname": "visual.types.graph.NodeWeight", "modulename": "visual.types.graph", "qualname": "NodeWeight", "kind": "variable", "doc": "<p></p>\n", "default_value": "Hashable"}, {"fullname": "visual.types.graph.NodesGraph", "modulename": "visual.types.graph", "qualname": "NodesGraph", "kind": "class", "doc": "<p>!!! abstract \"Usage Documentation\"\n    <a href=\"../concepts/models.md\">Models</a></p>\n\n<p>A base class for creating Pydantic models.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>__class_vars__:</strong>  The names of the class variables defined on the model.</li>\n<li><strong>__private_attributes__:</strong>  Metadata about the private attributes of the model.</li>\n<li><strong>__signature__:</strong>  The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</li>\n<li><strong>__pydantic_complete__:</strong>  Whether model building is completed, or if there are still undefined fields.</li>\n<li><strong>__pydantic_core_schema__:</strong>  The core schema of the model.</li>\n<li><strong>__pydantic_custom_init__:</strong>  Whether the model has a custom <code>__init__</code> function.</li>\n<li><strong>__pydantic_decorators__:</strong>  Metadata containing the decorators defined on the model.\nThis replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</li>\n<li><strong>__pydantic_generic_metadata__:</strong>  Metadata for generic models; contains data used for a similar purpose to\n__args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.</li>\n<li><strong>__pydantic_parent_namespace__:</strong>  Parent namespace of the model, used for automatic rebuilding of models.</li>\n<li><strong>__pydantic_post_init__:</strong>  The name of the post-init method for the model, if defined.</li>\n<li><strong>__pydantic_root_model__:</strong>  Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</li>\n<li><strong>__pydantic_serializer__:</strong>  The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</li>\n<li><strong>__pydantic_validator__:</strong>  The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</li>\n<li><strong>__pydantic_fields__:</strong>  A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</li>\n<li><strong>__pydantic_computed_fields__:</strong>  A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</li>\n<li><strong>__pydantic_extra__:</strong>  A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]\nis set to <code>'allow'</code>.</li>\n<li><strong>__pydantic_fields_set__:</strong>  The names of fields explicitly set during instantiation.</li>\n<li><strong>__pydantic_private__:</strong>  Values of private attributes set on the model instance.</li>\n</ul>\n", "bases": "Graph"}, {"fullname": "visual.types.graph.NodesGraph.type", "modulename": "visual.types.graph", "qualname": "NodesGraph.type", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Literal[&#x27;nodes&#x27;]", "default_value": "&#x27;nodes&#x27;"}, {"fullname": "visual.types.graph.NodesGraph.content", "modulename": "visual.types.graph", "qualname": "NodesGraph.content", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str | visual.types.graph.NodesGraphContent", "default_value": "PydanticUndefined"}, {"fullname": "visual.types.graph.NodesGraphContent", "modulename": "visual.types.graph", "qualname": "NodesGraphContent", "kind": "class", "doc": "<p>!!! abstract \"Usage Documentation\"\n    <a href=\"../concepts/models.md\">Models</a></p>\n\n<p>A base class for creating Pydantic models.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>__class_vars__:</strong>  The names of the class variables defined on the model.</li>\n<li><strong>__private_attributes__:</strong>  Metadata about the private attributes of the model.</li>\n<li><strong>__signature__:</strong>  The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</li>\n<li><strong>__pydantic_complete__:</strong>  Whether model building is completed, or if there are still undefined fields.</li>\n<li><strong>__pydantic_core_schema__:</strong>  The core schema of the model.</li>\n<li><strong>__pydantic_custom_init__:</strong>  Whether the model has a custom <code>__init__</code> function.</li>\n<li><strong>__pydantic_decorators__:</strong>  Metadata containing the decorators defined on the model.\nThis replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</li>\n<li><strong>__pydantic_generic_metadata__:</strong>  Metadata for generic models; contains data used for a similar purpose to\n__args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.</li>\n<li><strong>__pydantic_parent_namespace__:</strong>  Parent namespace of the model, used for automatic rebuilding of models.</li>\n<li><strong>__pydantic_post_init__:</strong>  The name of the post-init method for the model, if defined.</li>\n<li><strong>__pydantic_root_model__:</strong>  Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</li>\n<li><strong>__pydantic_serializer__:</strong>  The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</li>\n<li><strong>__pydantic_validator__:</strong>  The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</li>\n<li><strong>__pydantic_fields__:</strong>  A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</li>\n<li><strong>__pydantic_computed_fields__:</strong>  A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</li>\n<li><strong>__pydantic_extra__:</strong>  A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]\nis set to <code>'allow'</code>.</li>\n<li><strong>__pydantic_fields_set__:</strong>  The names of fields explicitly set during instantiation.</li>\n<li><strong>__pydantic_private__:</strong>  Values of private attributes set on the model instance.</li>\n</ul>\n", "bases": "pydantic.main.BaseModel"}, {"fullname": "visual.types.graph.NodesGraphContent.value", "modulename": "visual.types.graph", "qualname": "NodesGraphContent.value", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dict[str, visual.types.graph.NodesGraphContentItem]", "default_value": "PydanticUndefined"}, {"fullname": "visual.types.graph.NodesGraphContent.pointers", "modulename": "visual.types.graph", "qualname": "NodesGraphContent.pointers", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list[visual.types.graph.Pointer]", "default_value": "PydanticUndefined"}, {"fullname": "visual.types.graph.NodesGraphContentItem", "modulename": "visual.types.graph", "qualname": "NodesGraphContentItem", "kind": "class", "doc": "<p>!!! abstract \"Usage Documentation\"\n    <a href=\"../concepts/models.md\">Models</a></p>\n\n<p>A base class for creating Pydantic models.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>__class_vars__:</strong>  The names of the class variables defined on the model.</li>\n<li><strong>__private_attributes__:</strong>  Metadata about the private attributes of the model.</li>\n<li><strong>__signature__:</strong>  The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</li>\n<li><strong>__pydantic_complete__:</strong>  Whether model building is completed, or if there are still undefined fields.</li>\n<li><strong>__pydantic_core_schema__:</strong>  The core schema of the model.</li>\n<li><strong>__pydantic_custom_init__:</strong>  Whether the model has a custom <code>__init__</code> function.</li>\n<li><strong>__pydantic_decorators__:</strong>  Metadata containing the decorators defined on the model.\nThis replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</li>\n<li><strong>__pydantic_generic_metadata__:</strong>  Metadata for generic models; contains data used for a similar purpose to\n__args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.</li>\n<li><strong>__pydantic_parent_namespace__:</strong>  Parent namespace of the model, used for automatic rebuilding of models.</li>\n<li><strong>__pydantic_post_init__:</strong>  The name of the post-init method for the model, if defined.</li>\n<li><strong>__pydantic_root_model__:</strong>  Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</li>\n<li><strong>__pydantic_serializer__:</strong>  The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</li>\n<li><strong>__pydantic_validator__:</strong>  The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</li>\n<li><strong>__pydantic_fields__:</strong>  A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</li>\n<li><strong>__pydantic_computed_fields__:</strong>  A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</li>\n<li><strong>__pydantic_extra__:</strong>  A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]\nis set to <code>'allow'</code>.</li>\n<li><strong>__pydantic_fields_set__:</strong>  The names of fields explicitly set during instantiation.</li>\n<li><strong>__pydantic_private__:</strong>  Values of private attributes set on the model instance.</li>\n</ul>\n", "bases": "pydantic.main.BaseModel"}, {"fullname": "visual.types.graph.NodesGraphContentItem.value", "modulename": "visual.types.graph", "qualname": "NodesGraphContentItem.value", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": "PydanticUndefined"}, {"fullname": "visual.types.graph.NodesGraphContentItem.nexts", "modulename": "visual.types.graph", "qualname": "NodesGraphContentItem.nexts", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list[tuple[str, str]]", "default_value": "PydanticUndefined"}, {"fullname": "visual.types.snapshot", "modulename": "visual.types.snapshot", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "visual.types.snapshot.Snapshot", "modulename": "visual.types.snapshot", "qualname": "Snapshot", "kind": "class", "doc": "<p>!!! abstract \"Usage Documentation\"\n    <a href=\"../concepts/models.md\">Models</a></p>\n\n<p>A base class for creating Pydantic models.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>__class_vars__:</strong>  The names of the class variables defined on the model.</li>\n<li><strong>__private_attributes__:</strong>  Metadata about the private attributes of the model.</li>\n<li><strong>__signature__:</strong>  The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</li>\n<li><strong>__pydantic_complete__:</strong>  Whether model building is completed, or if there are still undefined fields.</li>\n<li><strong>__pydantic_core_schema__:</strong>  The core schema of the model.</li>\n<li><strong>__pydantic_custom_init__:</strong>  Whether the model has a custom <code>__init__</code> function.</li>\n<li><strong>__pydantic_decorators__:</strong>  Metadata containing the decorators defined on the model.\nThis replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</li>\n<li><strong>__pydantic_generic_metadata__:</strong>  Metadata for generic models; contains data used for a similar purpose to\n__args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.</li>\n<li><strong>__pydantic_parent_namespace__:</strong>  Parent namespace of the model, used for automatic rebuilding of models.</li>\n<li><strong>__pydantic_post_init__:</strong>  The name of the post-init method for the model, if defined.</li>\n<li><strong>__pydantic_root_model__:</strong>  Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</li>\n<li><strong>__pydantic_serializer__:</strong>  The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</li>\n<li><strong>__pydantic_validator__:</strong>  The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</li>\n<li><strong>__pydantic_fields__:</strong>  A dictionary of field names and their corresponding [<code>FieldInfo</code>][pydantic.fields.FieldInfo] objects.</li>\n<li><strong>__pydantic_computed_fields__:</strong>  A dictionary of computed field names and their corresponding [<code>ComputedFieldInfo</code>][pydantic.fields.ComputedFieldInfo] objects.</li>\n<li><strong>__pydantic_extra__:</strong>  A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]\nis set to <code>'allow'</code>.</li>\n<li><strong>__pydantic_fields_set__:</strong>  The names of fields explicitly set during instantiation.</li>\n<li><strong>__pydantic_private__:</strong>  Values of private attributes set on the model instance.</li>\n</ul>\n", "bases": "pydantic.main.BaseModel"}, {"fullname": "visual.types.snapshot.Snapshot.line", "modulename": "visual.types.snapshot", "qualname": "Snapshot.line", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": "PydanticUndefined"}, {"fullname": "visual.types.snapshot.Snapshot.graph_group", "modulename": "visual.types.snapshot", "qualname": "Snapshot.graph_group", "kind": "variable", "doc": "<p></p>\n", "annotation": ": visual.types.graph.GraphGroup", "default_value": "PydanticUndefined"}, {"fullname": "visual.types.snapshot.Snapshot.stdout", "modulename": "visual.types.snapshot", "qualname": "Snapshot.stdout", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": "&#x27;&#x27;"}, {"fullname": "visual.types.snapshot.Snapshot.event", "modulename": "visual.types.snapshot", "qualname": "Snapshot.event", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Literal[&#x27;line&#x27;, &#x27;call&#x27;, &#x27;return&#x27;]", "default_value": "PydanticUndefined"}, {"fullname": "visual.types.watchable", "modulename": "visual.types.watchable", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "visual.types.watchable.Watchable", "modulename": "visual.types.watchable", "qualname": "Watchable", "kind": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "abc.ABC"}, {"fullname": "visual.types.watchable.Watchable.__init__", "modulename": "visual.types.watchable", "qualname": "Watchable.__init__", "kind": "function", "doc": "<p><strong>Provide variable names or expressions but not both.</strong> <code>expr=False</code> looks up <code>vars</code> arguments by name at locals/globals of the execution frame which has better performance. <code>expr=True</code> treats <code>vars</code> arguments as expressions and directly evaluate them by using <code>eval()</code> during capture.</p>\n\n<p><strong>Use <code>expr=False</code> in most cases.</strong> Use <code>expr=True</code> when you must watch a composite expression or computation that is not stored in a simple variable.</p>\n\n<h6 id=\"examples\">Examples:</h6>\n\n<blockquote>\n  <div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">Watchable</span><span class=\"p\">(</span><span class=\"s1\">&#39;i&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">Watchable</span><span class=\"p\">(</span><span class=\"s1\">&#39;i + j&#39;</span><span class=\"p\">,</span> <span class=\"n\">expr</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span> <span class=\"c1\"># The varname will be &#39;i + j&#39; in this case</span>\n<span class=\"n\">Watchable</span><span class=\"p\">(</span><span class=\"s1\">&#39;i, j&#39;</span><span class=\"p\">,</span> <span class=\"n\">expr</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span> <span class=\"c1\"># Notice that it&#39;s not Watchable(&#39;i, j&#39;)</span>\n\n<span class=\"c1\"># Wrong usage</span>\n<span class=\"n\">Watchable</span><span class=\"p\">()</span>\n</code></pre>\n  </div>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">var</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">expr</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span>)</span>"}, {"fullname": "visual.types.watchable.Watchable.capture", "modulename": "visual.types.watchable", "qualname": "Watchable.capture", "kind": "function", "doc": "<p>Capture the current state of the watchable variable from the given frame</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>frame (FrameType | None):</strong>  The execution frame. If None, it uses the parent frame (the frame which called this function).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Any: The captured value of the watchable variable, or _NotCaptured if not found.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">frame</span><span class=\"p\">:</span> <span class=\"n\">frame</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "visual.types.watchable.Watchable.generate_graph", "modulename": "visual.types.watchable", "qualname": "Watchable.generate_graph", "kind": "function", "doc": "<p>Generate a graph representation of the watchable variable.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>frame (FrameType | None):</strong>  The execution frame. If None, it uses the parent frame (the frame which called this function).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Graph: The generated graph representation</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">frame</span><span class=\"p\">:</span> <span class=\"n\">frame</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">GraphUnion</span>:</span></span>", "funcdef": "def"}, {"fullname": "visual.types.watchable.Var", "modulename": "visual.types.watchable", "qualname": "Var", "kind": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "Watchable"}, {"fullname": "visual.types.watchable.Var.__init__", "modulename": "visual.types.watchable", "qualname": "Var.__init__", "kind": "function", "doc": "<p><strong>Provide variable names or expressions but not both.</strong> <code>expr=False</code> looks up <code>vars</code> arguments by name at locals/globals of the execution frame which has better performance. <code>expr=True</code> treats <code>vars</code> arguments as expressions and directly evaluate them by using <code>eval()</code> during capture.</p>\n\n<p><strong>Use <code>expr=False</code> in most cases.</strong> Use <code>expr=True</code> when you must watch a composite expression or computation that is not stored in a simple variable.</p>\n\n<h6 id=\"examples\">Examples:</h6>\n\n<blockquote>\n  <div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">Watchable</span><span class=\"p\">(</span><span class=\"s1\">&#39;i&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">Watchable</span><span class=\"p\">(</span><span class=\"s1\">&#39;i + j&#39;</span><span class=\"p\">,</span> <span class=\"n\">expr</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span> <span class=\"c1\"># The varname will be &#39;i + j&#39; in this case</span>\n<span class=\"n\">Watchable</span><span class=\"p\">(</span><span class=\"s1\">&#39;i, j&#39;</span><span class=\"p\">,</span> <span class=\"n\">expr</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span> <span class=\"c1\"># Notice that it&#39;s not Watchable(&#39;i, j&#39;)</span>\n\n<span class=\"c1\"># Wrong usage</span>\n<span class=\"n\">Watchable</span><span class=\"p\">()</span>\n</code></pre>\n  </div>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">var</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">expr</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span>)</span>"}, {"fullname": "visual.types.watchable.Var.generate_graph", "modulename": "visual.types.watchable", "qualname": "Var.generate_graph", "kind": "function", "doc": "<p>Generate a graph representation of the watchable variable.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>frame (FrameType | None):</strong>  The execution frame. If None, it uses the parent frame (the frame which called this function).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Graph: The generated graph representation</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">frame</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">visual</span><span class=\"o\">.</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">VarGraph</span>:</span></span>", "funcdef": "def"}, {"fullname": "visual.types.watchable.DS", "modulename": "visual.types.watchable", "qualname": "DS", "kind": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "Watchable, abc.ABC"}, {"fullname": "visual.types.watchable.DS.get_index_dict", "modulename": "visual.types.watchable", "qualname": "DS.get_index_dict", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "visual.types.watchable.DS.get_item_dict", "modulename": "visual.types.watchable", "qualname": "DS.get_item_dict", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "visual.types.watchable.DS.add_index", "modulename": "visual.types.watchable", "qualname": "DS.add_index", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">var</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">expr</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "visual.types.watchable.DS.add_item", "modulename": "visual.types.watchable", "qualname": "DS.add_item", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">var</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">expr</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "visual.types.watchable.DS.remove_index", "modulename": "visual.types.watchable", "qualname": "DS.remove_index", "kind": "function", "doc": "<p><strong>Not recommended to use.</strong> Information increment is better than decrement. If you really want to constrain the effective index/item effective scope, use <code>with</code> statement.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">var</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "visual.types.watchable.DS.remove_item", "modulename": "visual.types.watchable", "qualname": "DS.remove_item", "kind": "function", "doc": "<p><strong>Not recommended to use.</strong> Information increment is better than decrement. If you really want to constrain the effective index/item effective scope, use <code>with</code> statement.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">var</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "visual.types.watchable.Array", "modulename": "visual.types.watchable", "qualname": "Array", "kind": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "DS"}, {"fullname": "visual.types.watchable.Array.__init__", "modulename": "visual.types.watchable", "qualname": "Array.__init__", "kind": "function", "doc": "<p><strong>Provide variable names or expressions but not both.</strong> <code>expr=False</code> looks up <code>vars</code> arguments by name at locals/globals of the execution frame which has better performance. <code>expr=True</code> treats <code>vars</code> arguments as expressions and directly evaluate them by using <code>eval()</code> during capture.</p>\n\n<p><strong>Use <code>expr=False</code> in most cases.</strong> Use <code>expr=True</code> when you must watch a composite expression or computation that is not stored in a simple variable.</p>\n\n<h6 id=\"examples\">Examples:</h6>\n\n<blockquote>\n  <div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">Watchable</span><span class=\"p\">(</span><span class=\"s1\">&#39;i&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">Watchable</span><span class=\"p\">(</span><span class=\"s1\">&#39;i + j&#39;</span><span class=\"p\">,</span> <span class=\"n\">expr</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span> <span class=\"c1\"># The varname will be &#39;i + j&#39; in this case</span>\n<span class=\"n\">Watchable</span><span class=\"p\">(</span><span class=\"s1\">&#39;i, j&#39;</span><span class=\"p\">,</span> <span class=\"n\">expr</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span> <span class=\"c1\"># Notice that it&#39;s not Watchable(&#39;i, j&#39;)</span>\n\n<span class=\"c1\"># Wrong usage</span>\n<span class=\"n\">Watchable</span><span class=\"p\">()</span>\n</code></pre>\n  </div>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">var</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">expr</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span>)</span>"}, {"fullname": "visual.types.watchable.Array.generate_graph", "modulename": "visual.types.watchable", "qualname": "Array.generate_graph", "kind": "function", "doc": "<p>Generate a graph representation of the watchable variable.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>frame (FrameType | None):</strong>  The execution frame. If None, it uses the parent frame (the frame which called this function).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Graph: The generated graph representation</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">frame</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">visual</span><span class=\"o\">.</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">ArrayGraph</span>:</span></span>", "funcdef": "def"}, {"fullname": "visual.types.watchable.Array2D", "modulename": "visual.types.watchable", "qualname": "Array2D", "kind": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "DS"}, {"fullname": "visual.types.watchable.Array2D.__init__", "modulename": "visual.types.watchable", "qualname": "Array2D.__init__", "kind": "function", "doc": "<p><strong>Provide variable names or expressions but not both.</strong> <code>expr=False</code> looks up <code>vars</code> arguments by name at locals/globals of the execution frame which has better performance. <code>expr=True</code> treats <code>vars</code> arguments as expressions and directly evaluate them by using <code>eval()</code> during capture.</p>\n\n<p><strong>Use <code>expr=False</code> in most cases.</strong> Use <code>expr=True</code> when you must watch a composite expression or computation that is not stored in a simple variable.</p>\n\n<h6 id=\"examples\">Examples:</h6>\n\n<blockquote>\n  <div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">Watchable</span><span class=\"p\">(</span><span class=\"s1\">&#39;i&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">Watchable</span><span class=\"p\">(</span><span class=\"s1\">&#39;i + j&#39;</span><span class=\"p\">,</span> <span class=\"n\">expr</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span> <span class=\"c1\"># The varname will be &#39;i + j&#39; in this case</span>\n<span class=\"n\">Watchable</span><span class=\"p\">(</span><span class=\"s1\">&#39;i, j&#39;</span><span class=\"p\">,</span> <span class=\"n\">expr</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span> <span class=\"c1\"># Notice that it&#39;s not Watchable(&#39;i, j&#39;)</span>\n\n<span class=\"c1\"># Wrong usage</span>\n<span class=\"n\">Watchable</span><span class=\"p\">()</span>\n</code></pre>\n  </div>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">var</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">expr</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span>)</span>"}, {"fullname": "visual.types.watchable.Array2D.generate_graph", "modulename": "visual.types.watchable", "qualname": "Array2D.generate_graph", "kind": "function", "doc": "<p>Generate a graph representation of the watchable variable.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>frame (FrameType | None):</strong>  The execution frame. If None, it uses the parent frame (the frame which called this function).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Graph: The generated graph representation</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">frame</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">visual</span><span class=\"o\">.</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">Array2DGraph</span>:</span></span>", "funcdef": "def"}, {"fullname": "visual.types.watchable.Array3D", "modulename": "visual.types.watchable", "qualname": "Array3D", "kind": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "DS"}, {"fullname": "visual.types.watchable.ArrayND", "modulename": "visual.types.watchable", "qualname": "ArrayND", "kind": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "DS"}, {"fullname": "visual.types.watchable.Tensor", "modulename": "visual.types.watchable", "qualname": "Tensor", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;class &#x27;visual.types.watchable.ArrayND&#x27;&gt;"}, {"fullname": "visual.types.watchable.Nodes", "modulename": "visual.types.watchable", "qualname": "Nodes", "kind": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "DS, typing.Generic[_NodesType, _NodeType, _IdType, _WeightType]"}, {"fullname": "visual.types.watchable.Nodes.generate_graph", "modulename": "visual.types.watchable", "qualname": "Nodes.generate_graph", "kind": "function", "doc": "<p>Generate a graph representation of the watchable variable.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>frame (FrameType | None):</strong>  The execution frame. If None, it uses the parent frame (the frame which called this function).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Graph: The generated graph representation</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">frame</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">visual</span><span class=\"o\">.</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">NodesGraph</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();